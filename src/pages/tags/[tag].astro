---
import BaseLayout from "../../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

/** Convert a module key (e.g. "../../pages/gigs/index.astro") into a route URL (e.g. "/gigs/"). */
function pathToUrl(key) {
  // drop any leading ../ segments before "pages"
  let p = key.replace(/^(\.\.\/)+pages/i, "");
  // ensure leading slash
  if (!p.startsWith("/")) p = "/" + p;
  // drop extension
  p = p.replace(/\.astro$/i, "");
  // collapse duplicate slashes
  p = p.replace(/\/{2,}/g, "/");
  // handle index routes
  if (p === "/index") return "/";
  if (p.endsWith("/index")) p = p.slice(0, -("/index".length));
  // ensure trailing slash for directory routes
  if (!p.endsWith("/")) p = p + "/";
  return p;
}

// Build all tag pages (tags discovered from content + route pages)
export async function getStaticPaths() {
  const entries = await getCollection("pages");
  const tagSet = new Set();
  for (const e of entries) (e.data.tags || []).forEach((t) => tagSet.add(String(t).toLowerCase().trim()));

  const routeMods = import.meta.glob("../../pages/**/*.astro", { eager: true }) as Record<string, any>;
  for (const [path, mod] of Object.entries(routeMods)) {
    // ignore tag/archive and content templates themselves
    if (path.includes("/pages/tags/") || path.includes("/pages/content/")) continue;
    const arr = (mod?.pageTags || mod?.tags || []) as unknown[];
    arr?.forEach((t) => {
      const key = String(t || "").toLowerCase().trim();
      if (key) tagSet.add(key);
    });
  }

  return Array.from(tagSet).map((tag) => ({ params: { tag }, props: { tag } }));
}

const { tag } = Astro.props as { tag: string };

// Gather matches from content collection
const allContent = await getCollection("pages");
const matchesContent = allContent
  .filter((p) => (p.data.tags || []).map((t) => String(t).toLowerCase().trim()).includes(tag))
  .map((p) => ({ title: p.data.title ?? p.slug, url: `/content/${p.slug}/` }));

// Gather matches from route pages (require pageTags export)
const routeMods = import.meta.glob("../../pages/**/*.astro", { eager: true }) as Record<string, any>;
const matchesRoutes: { title: string; url: string }[] = [];
for (const [path, mod] of Object.entries(routeMods)) {
  if (path.includes("/pages/tags/") || path.includes("/pages/content/")) continue;
  const arr = (mod?.pageTags || mod?.tags || []) as unknown[];
  const has = arr?.some((t) => String(t || "").toLowerCase().trim() === tag);
  if (!has) continue;
  const title = String(mod?.pageTitle || mod?.title || pathToUrl(path)).trim();
  const url = pathToUrl(path);
  matchesRoutes.push({ title, url });
}

const items = [...matchesContent, ...matchesRoutes];
---
<BaseLayout title={`#${tag}`} description={`Pages tagged ${tag}`}>
  {items.length === 1 ? (
    <>
      <meta http-equiv="refresh" content={`0; url=${items[0].url}`} />
      <p>Redirecting to <a href={items[0].url}>{items[0].title}</a>â€¦</p>
    </>
  ) : (
    <>
      <h1>#{tag}</h1>
      {items.length === 0 ? (
        <p>No pages yet.</p>
      ) : (
        <ul>
          {items.map((it) => (
            <li><a href={it.url}>{it.title}</a></li>
          ))}
        </ul>
      )}
    </>
  )}
</BaseLayout>
